## типы данных MASM. Оператор dup. Секции data и const. Оператор typedef

в ассемблере можно создавать переменные вида:
```
label directive value
```
- label - имя переменной
- directive - тип переменной

Часто первая буква имени переменной указывает тип данных переменной.

### Типы данных:
byte (или db): 8-битное целое число без знака

sbyte: 8-битное целое число со знаком

word (или dw): 16-битное целое число без знака (или слово)

sword: 16-битное целое число со знаком

dword (или dd): 32-битное целое число без знака (или двойное слово)

sdword: 32-битное целое число со знаком

qword (или dq): 64-битное целое число без знака (или четверное слово)

sqword: 64-битное целое число со знаком

tbyte (или dt): 80-битное целое число без знака

oword: 128-битное целое число без знака (восьмерное слово)

real4: число с плавающей точкой одинарной точности (32 бита)

real8: число с плавающей точкой двойной точности (64 бита)

real10: число с плавающей точкой расширенной точности (80 бит)

xmmword: вектор размером 128 байт, применяется в операциях SIMD для работы с регистрами XMM

ymmword: вектор размером 256 байт, применяется в операциях SIMD для работы с регистрами YMM

zmmword: вектор размером 512 байт, применяется в операциях SIMD для работы с регистрами ZMM

### пример переменной
```
number byte 22
```

Можно объявить набор значений:
```
nums byte 1, 2, 3, 0, 10
```
Здесь переменная nums займет 5 байт

#### переменные можно создавать в разных секциях кода

### секция .code
можно создавать переменные в секции .code

```
.code
i32 dword 123   ; определеяем объект i32
 
main proc
    mov eax, i32    ; помещаем число i32 в регистр eax
    ret
main endp
end
```

Но секция .code больше создана для инструкций, ибо из .code можно только считывать данные, но не записывать их. 

При записи данных в .code выдает ошибку 
general protection fault

### секция .data
Для определения данных есть эта секция. Причем в памяти данные будут идти друг за другом. 
```
.data
i32 dword 5     ; определяем переменную i32
.code
main proc
    mov eax, i32    ; помещаем значение переменной в регистр EAX
    ret
main endp
end
```

### оператор dup
dup нужен для повторяющегося набора данных (массива). 
```
имя_переменной тип размер dup (значение)
```
Например:
```
numbers byte 5 dup (0)
```
Это массив из 5 байт, где каждый элемент нулевой.

Или же можно писать так:
```
numbers byte 1, 2, 3, 4 
             5, 6, 7, 8
```

### неинициализированные значения
вместо значения укажем знак вопроса. Тогда переменная будет хранить произвольное значение (чаще всего 0)
```
.data?
i64 qword ?
text byte 5 dup (?)
```
Часто переменные без инициализации идут в секции .data?

### секция .const
нужна для констант
```
.const
    c32 dword 22    ; константа - ее нельзя изменить
.code
main proc
    mov eax, c32    ; помещаем значение константы в регистр EAX
    ret
main endp
end
```
### секции идут в произвольном порядке и могут повторятся
```
.data
    n1 dword 1
 
.const
    c1 dword 11
 
.data
    n2 dword 2
 
.const
    c2 dword 12
 
.code
main proc
    mov eax, c2
    ret
main endp
end
```
### typedef
нужен для псевдонимов типов
```
int32 typedef sdword
long typedef sqword
int16 typedef sword
 
.data
    n1 int32 32
    n2 long 64
    n3 int16 16
.code
main proc
    mov eax, n1
    ret
main endp
end
```
### разные системы счисления в MASM
По умолчанию все числа в 10-системе.

Для двоичной или 16-системы нужны буквы b и h в конце:
```
.data
i64 qword 80h           ; число в 16-й системе - 128
i8 byte 00001011b       ; число в двоичной системе - 11
```
Если щестнадцатеричное число начинается на алфавитный символ (A-F), то перед ним указывается 0:
```
.data
    n dword 0FFh    ; n = 255
```