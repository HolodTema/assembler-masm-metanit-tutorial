## регистр flags и условные переходы

В ассемблере есть команды, выполняющие условные переходы в зависимости от битов в FLAGS.

Учитываются 4 бита: 
- carry (флаг переноса)
- overflow (флаг переполнения)
- sign (флаг знака)
- zero (флаг нуля)

### CF - carry - флаг переноса
устанавливается при беззнаковом переполнении: при сумме с переносом или при вычитании с заимствованием.

### OF - overflow - флаг переполнения
устанавливается при знаковом переполнении. Когда переполняется бит после знакового бита. Из-за этого может измениться старший знаковый бит и установится флаг:
```
0111 1111 + 
0000 0001 =
1000 0000 
знаковый бит изменился, ибо не хватило места для бита.
```
### SF - sign - флаг знака
устанавливается в соответствии со старшим знаковым битом результата. 

### ZF - zero - флаг нуля
устанавливается, если результат вычисления равен нулю.

### флаг установлен - что это значит
Флаг установлен - его бит = 1

Флаг сброшен - его бит = 0

### инструкции, меняющие флаги
add, sub, and, or, xor, not меняют флаги. 

mov и lea флаги не меняют 

и тд

### условные переходы
- jc (jb): выполняет переход к метке, если флаг переноса установлен

- jnc: выполняет переход к метке, если флаг переноса НЕ установлен

- jo: выполняет переход к метке, если флаг переполнения установлен

- jno: выполняет переход к метке, если флаг переполнения не установлен

- js: выполняет переход к метке, если флаг знака установлен

- jns: выполняет переход к метке, если флаг знака не установлен

- jz (je): выполняет переход к метке, если флаг нуля установлен

- jnz (jne): выполняет переход к метке, если флаг нуля не установлен

Все они принимают один операнд - метку.
### пример

```
.code
main proc
    mov eax, 0FFFFFFFFh
    mov ebx, 1
    add eax, ebx
    jc carry_set
    mov eax, 0
    ret
carry_set:
    mov eax, 1
    ret
main endp
end
```
здесь при сложении eax + ebx будет перенос - флаг переноса будет 1. И поэтому будет переход к метке carry_set.

### еще пример
```
.code
main proc
    mov rax, 5
    mov rbx, 5
    sub rax, rbx 
    ; zero flag is set
    jz zero_set
    mov eax, 2
    ret
zero_set:
    mov eax, 4
    ret
main endp
end
```

### простой цикл через условные переходы
```
.code 
main proc
    mov rax, 0
    mov rcx, 5
main_loop:
    add rax, 2
    sub rcx, 1
    jnz main_loop
    ret
main endp
end
```
Здесь rcx работает как счетчик цикла, всего будет 5 итераций. Внутри каждой итерации делаем rax+=2.

Причем сама метка в коде не мешает исполнять код дальше. Операции идут сверху вниз, метка им не мешает.
