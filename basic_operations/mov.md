# mov
До 40% всех инструкций - это mov.

```
mov destination, source

по типу destination = source
```
Инструкция копирует данные из source в destination.
### непосредственный операнд
непосредственный операнд (immediate operand) - числовой или символьный литерал.
### пример
```
.code
main proc
    mov rax, 22
    ret
main endp
end
```
здесь в регистр rax помещают непосредственный операнд - число 22

Регистр rax служит кодом статуса выполнения программы. Если rax содержит 0, значит программа выполнена успешно. 

(Также можно помещать код статуса и в младшие части rax - регистры eax и al при условии, что остальная часть регистра rax содержит 0)

Для проверки в консоли можно вызвать:
```
ml64 hello.asm /link /entry:main

echo %ERRORLEVEL%
```

### mov и ограничение операндов по размеру
операнды mov должны быть одинаковы по размеру. 

Однако константы и непосредственные операнды могут быть меньше операнда-регистра.

```
.data
    i32 dword 4
.code
main proc
    mov eax, i32    ; помещаем в регистр eax значение переменной i32
    ret
main endp
end
```
Здесь переменная i32 весит 32 бита. Регистр eax также размером в 32 бита. Проблем нет.

А вот здесь будет ошибка: нельзя поместить 8-битную переменную в 64-битный регистр:
```
.data
    i8 byte 8
.code
main proc
    mov rax, i8 ; error!
    ret
main endp
end
```

Аналогично нельзя поместить в регистр константу, большую чем этот регистр:
```
.code
main proc
    mov al, 512 ; ошибка!
    ret
main endp
end
```

### movsx и movzx
Архитектура x86-64 сделала разновидности mov для операндов разных размеров.

### movsx

Если источник по размеру меньше приемника, movsx расширяет данные по знаку при копировании.

При этом приемник должен быть регистром и быть >= по размеру, чем источник. Также нельзя совать константные значения.

```
.code
main proc
    mov dl, -5
    movsx eax, dl ; теперь eax = -5
    ret
main endp
end
```
### movzx
movzx делает беззнаковое расширение нулями:
```
.code
main proc
    mov dl, 5
    movzx eax, dl
    ret
main endp
end




