## cmp
cmp позволяет сравнить значения и установить флаги. Далее значения флагов можно брать для условного перехода.

```
cmp left_operand, right_operand
```
- float-числа не сравниваются
- константы и непосредственные операнды не более 32 бит

cmp вычитает из первого операнда второй (как и sub), устанавливает флаги, но не сохраняет результат в первый операнд.

### как использовать
```
cmp ax, bx
```
- если ax = bx, то флаг zf = 1

- если ax >= bx, то SF = OF

- если ax < bx, то SF != OF

### команды условного перехода
Специально для cmp сделали еще больше инструкций условного перехода! (как мы рады)

#### вне зависимости от знака операндов

- je проверяет условие ZF==1 (если ax == bx)

- jne проверяет условие ZF==0
(если ax != ebx)

#### оба операнда беззнаковые

- ja (jnbe) для ax > bx. Оба операнда беззнаковые.

- jae (jnb) для ax >= bx.
Оба операнда беззнаковые.

-jb (jnae) для ax < bx.
Оба операнда беззнаковые

- jbe (jna) для ax <= bx.
Оба операнда беззнаковые

#### оба операнда знаковые
- jg (jnle) для ax > bx. Оба операнда знаковые.

- jge (jnl) для ax >= bx.
Оба операнда знаковые.

-jl (jnge) для ax < bx.
Оба операнда знаковые

- jle (jng) для ax <= bx.
Оба операнда знаковые

### пример
```
.data
    n1 byte 22
    n2 byte 33
.code
main proc
    mov al, n1
    cmp al, n2
    jne not_equal
    mov eax, 0 ; не выполнится
    ret
not_equal: 
    mov eax, 1
    ret
main endp
end
```



